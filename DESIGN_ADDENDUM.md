# Design Addendum: Manual Decision Lock-In

**Project:** Real-Time Subscription Entitlement Enforcement Platform  
**Date:** January 27, 2026  
**Author:** Senior Data Engineer (Design Review)  
**Status:** LOCKED - All downstream components must align with these decisions

---

## 1. Subscription & Business Model

### What We're Building
A real-time enforcement system for a **usage-based SaaS API platform** that:
- Meters API calls per customer
- Enforces plan-based rate limits
- Detects abuse patterns
- Feeds billing and analytics systems

### Customer Definition
- **Customer:** B2B organization (tenant)
- **Identified by:** `tenant_id`
- **Authentication:** API keys issued per tenant (multiple keys per tenant allowed)
- **Billing entity:** Tenant, not individual API key

### What Is Being Enforced
- **Primary metric:** API request count
- **Secondary metrics:** Request size (bytes), response latency (SLA)
- **Enforcement actions:** Rate limit (429), throttle, alert, suspend

---

## 2. Entitlement Rules

### Metric Being Enforced

| Metric | Description | Unit |
|--------|-------------|------|
| `request_count` | Total API calls | Count |
| `billing_units` | Weighted call units (complex endpoints cost more) | Units |

### Time Windows

| Window | Duration | Purpose |
|--------|----------|---------|
| **Primary (Rate Limit)** | 1 minute | Burst protection, real-time enforcement |
| **Secondary (Quota)** | 1 hour | Sustained usage tracking |
| **Tertiary (Billing)** | 1 month (calendar) | Invoice generation |

**Justification:**
- 1-minute window catches sudden spikes (DDoS, runaway scripts)
- 1-hour window prevents sustained abuse within rate limits
- Monthly aligns with billing cycle

### Plan Tiers

| Tier | Requests/Minute | Requests/Hour | Requests/Month | Price |
|------|-----------------|---------------|----------------|-------|
| Free | 60 | 1,000 | 10,000 | $0 |
| Starter | 300 | 10,000 | 100,000 | $49/mo |
| Professional | 1,000 | 50,000 | 1,000,000 | $199/mo |
| Enterprise | 5,000 | 200,000 | 10,000,000 | Custom |

### Enforcement Conditions

**Over-Limit (Rate Limit Exceeded):**
```
condition: request_count_1min > plan.requests_per_minute
action: Return HTTP 429, include Retry-After header
```

**Soft Warning (Approaching Limit):**
```
condition: quota_used_percent >= 80%
action: Add X-RateLimit-Warning header, emit alert event
```

**Abuse / Anomaly Detection:**
```
conditions (any triggers investigation):
- velocity_1min > 2x historical average for this tenant
- unique_endpoints_1h > 50 (potential enumeration)
- error_rate_1h > 50% (potential attack probing)
- unique_ips_24h > 10 per API key (credential sharing)

action: Flag as suspicious, increase risk_score, alert security team
```

---

## 3. Event-Time & Late Data Policy

### Authoritative Timestamp

| Timestamp | Purpose | Source |
|-----------|---------|--------|
| `event_timestamp` | **Authoritative** for all processing | API gateway (when request received) |
| `ingestion_timestamp` | Latency tracking only | Kafka producer timestamp |
| `processed_at` | Audit trail | Silver/Gold processing time |

**Why event_timestamp?**
- Represents when the API call actually happened
- Consistent regardless of pipeline delays
- Required for accurate rate limit enforcement

### Watermark Policy

| Setting | Value | Justification |
|---------|-------|---------------|
| Watermark delay | **1 hour** | Covers network partitions, batch producer delays |
| Late event handling | **Flag, don't drop** | Late events still count for billing |

**What Happens Beyond Watermark:**
- Streaming aggregations may not include the event
- Event is still written to Silver table with `_is_late_arriving = true`
- Batch reconciliation job (daily) corrects any missed events
- Billing uses batch totals, not streaming totals (source of truth)

---

## 4. Deduplication & Idempotency

### Idempotency Key

| Key | Value | Generated By |
|-----|-------|--------------|
| Primary | `event_id` (UUIDv7) | API gateway |

**Why `event_id`?**
- Globally unique, collision-free
- Set at source (gateway is authoritative)
- Time-sortable (UUIDv7 embeds timestamp)

### Deduplication Layer

| Layer | Deduplication | Method |
|-------|---------------|--------|
| Bronze | None | Preserves raw data, including duplicates |
| **Silver** | **Yes** | Watermark + `dropDuplicates(event_id)` |
| Gold | Relies on Silver | Aggregates deduplicated data |

**Why Silver Layer?**
- Bronze must preserve raw data (audit, replay)
- Silver is "single source of truth" for clean data
- Gold aggregations would be wrong if duplicates present
- Deduping at Silver means doing it once, not in every Gold table

### Idempotency Guarantee

```
Same event processed 100 times = Same result as processing once

Mechanism:
1. Streaming: dropDuplicates with watermark (state-bounded)
2. Batch/Replay: Delta Lake MERGE on event_id (upsert)
```

---

## 5. Aggregation Semantics

### Window Type

| Aggregation | Window Type | Justification |
|-------------|-------------|---------------|
| Rate limiting (1 min) | **Tumbling** | Non-overlapping, matches enforcement granularity |
| Hourly rollups | **Tumbling** | Clean hour boundaries for quota tracking |
| Anomaly detection | **Sliding** (5 min slide on 1 hour) | Smooth trend detection, no sharp edges |

**Why Tumbling for Rate Limits?**
- Simple to reason about ("60 requests per minute window")
- Matches customer expectation
- Easier to explain in billing disputes
- Sliding would allow 120 requests across boundary (2x gaming)

### Grouping Keys

| Aggregation | Group By | Rationale |
|-------------|----------|-----------|
| Rate limiting | `tenant_id` | Enforcement is per-tenant |
| Per-key analytics | `tenant_id, api_key_id` | Track key-level abuse |
| Endpoint metrics | `tenant_id, endpoint_id` | Per-endpoint rate limits |
| Billing | `tenant_id, billing_cycle_id` | Invoice granularity |

### How This Supports Enforcement

```
Real-time path (sub-second):
  Gateway → Redis (current count) → Allow/Deny

Near-real-time path (1 minute):
  Silver → Gold aggregation → Update Redis → Sync limits

Billing path (end of month):
  Gold → Batch aggregation → Invoice system
```

---

## 6. Gold Layer Outputs

### Primary Gold Table: `gold.tenant_usage_1min`

**Purpose:** Real-time rate limit enforcement and alerting

| Column | Type | Description |
|--------|------|-------------|
| `tenant_id` | STRING | Tenant identifier (PK part 1) |
| `window_start` | TIMESTAMP | Start of 1-minute window (PK part 2) |
| `window_end` | TIMESTAMP | End of 1-minute window |
| `request_count` | LONG | Total requests in window |
| `billing_units` | DOUBLE | Weighted billing units |
| `error_count` | LONG | Requests with 4xx/5xx responses |
| `avg_latency_ms` | DOUBLE | Mean response latency |
| `p99_latency_ms` | DOUBLE | 99th percentile latency |
| `unique_endpoints` | LONG | Distinct endpoints accessed |
| `unique_api_keys` | LONG | Distinct API keys used |
| `rate_limited_count` | LONG | Requests that were rate limited |
| `plan_tier` | STRING | Tenant's plan at time of window |
| `limit_requests_per_min` | LONG | Plan limit for comparison |
| `usage_percent` | DOUBLE | request_count / limit × 100 |
| `is_over_limit` | BOOLEAN | request_count > limit |
| `processed_at` | TIMESTAMP | When this aggregate was computed |

**Partitioned by:** `date(window_start)`

### Secondary Gold Table: `gold.tenant_usage_hourly`

**Purpose:** Quota tracking, trend analysis, anomaly detection

| Column | Type | Description |
|--------|------|-------------|
| `tenant_id` | STRING | Tenant identifier |
| `window_start` | TIMESTAMP | Start of 1-hour window |
| `request_count` | LONG | Total requests |
| `billing_units` | DOUBLE | Total billing units |
| `avg_requests_per_min` | DOUBLE | Average rate across hour |
| `peak_requests_per_min` | LONG | Max 1-min count in hour |
| `quota_used_percent` | DOUBLE | Usage vs hourly quota |
| `anomaly_score` | DOUBLE | Statistical anomaly score |

### Tertiary Gold Table: `gold.tenant_usage_monthly`

**Purpose:** Billing, invoicing, capacity planning

| Column | Type | Description |
|--------|------|-------------|
| `tenant_id` | STRING | Tenant identifier |
| `billing_cycle_id` | STRING | Month identifier (2026-01) |
| `total_requests` | LONG | Sum of all requests |
| `total_billing_units` | DOUBLE | Billable amount |
| `plan_tier` | STRING | Plan for the month |
| `overage_units` | DOUBLE | Units above plan limit |
| `estimated_charge_usd` | DOUBLE | Calculated charge |

### Consumption Patterns

| Consumer | Gold Table | Usage |
|----------|------------|-------|
| Gateway (Redis) | `tenant_usage_1min` | Real-time limit check |
| Alerting | `tenant_usage_1min` | Over-limit notifications |
| Dashboard | `tenant_usage_hourly` | Customer usage portal |
| Billing | `tenant_usage_monthly` | Invoice generation |
| Analytics | All | Trend analysis, forecasting |

---

## 7. Consistency Check

### Assumptions Corrected

| Previous Assumption | Correction | Impact |
|---------------------|------------|--------|
| Watermark was undefined | Locked to 1 hour | Silver dedup logic aligned |
| Plan tiers vague | Concrete limits defined | Gold can compute `is_over_limit` |
| Enforcement action unclear | 429 + Retry-After defined | Gateway integration spec |
| Billing granularity open | Monthly calendar cycle | Gold table partitioning |
| Anomaly thresholds missing | Concrete rules added | Abuse detection logic |

### Layer Alignment Confirmation

**Bronze Layer:** ✓ Aligned
- Preserves raw JSON (`_raw_value`)
- No deduplication (correct)
- Captures all Kafka metadata for replay

**Silver Layer:** ✓ Aligned
- Deduplicates on `event_id`
- Uses `event_timestamp` (authoritative)
- 1-hour watermark
- Flags late events, doesn't drop
- Quarantines invalid records

**Gold Layer:** ✓ Aligned
- 1-minute tumbling windows for rate limits
- Groups by `tenant_id`
- Computes `is_over_limit` using plan limits
- Feeds Redis for real-time enforcement

### Data Flow Confirmation

```
API Gateway
    │
    ▼
Kafka (api-usage-events.v1)
    │ partition by: tenant_id
    │ retention: 7 days
    ▼
Bronze (Delta Lake)
    │ raw, immutable, no dedup
    │ retention: 90 days hot, 7 years archive
    ▼
Silver (Delta Lake)
    │ deduplicated on event_id
    │ watermark: 1 hour
    │ late events: flagged
    ▼
Gold (Delta Lake)
    │ 1-min, hourly, monthly aggregates
    │ grouped by tenant_id
    ▼
┌─────────────┬─────────────┬─────────────┐
│   Redis     │   Alerts    │   Billing   │
│ (enforcement)│ (PagerDuty) │  (Stripe)   │
└─────────────┴─────────────┴─────────────┘
```

---

## Sign-Off

These decisions are now **LOCKED**. Any changes require design review approval.

| Decision Area | Status |
|---------------|--------|
| Business model | ✅ Locked |
| Entitlement rules | ✅ Locked |
| Event-time policy | ✅ Locked |
| Deduplication strategy | ✅ Locked |
| Aggregation semantics | ✅ Locked |
| Gold schema | ✅ Locked |
| Layer alignment | ✅ Verified |

**Next Steps:**
1. Implement Gold layer aggregation job
2. Build Redis sync pipeline
3. Integrate with gateway for real-time enforcement
4. Set up alerting on `is_over_limit` events
